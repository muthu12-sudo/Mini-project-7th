import os
import zipfile
import pandas as pd
from pathlib import Path
from arcgis.gis import GIS
from arcgis.features import GeoAccessor
from arcgis.learn import SingleShotDetector
from fastai.vision.all import *

# Set up your API key and GIS connection
api_key = 'YOUR_API_KEY'  # Replace with your API key
gis = GIS(api_key=api_key)

# Define paths
model_path = 'path_to_saved_model.pth'  # Replace with the actual path to your saved model
data_path = 'path_to_data'  # Replace with the path where your data is stored

# Load the saved model
data = prepare_data(data_path, batch_size=8, chip_size=500, seed=42, dataset_type='PASCAL_VOC_rectangles')
ssd = SingleShotDetector.load(model_path, data)

# Function to predict and visualize results on image
def predict_image(img_path, model):
    bbox_data = model.predict(img_path, threshold=0.1, visualize=True)
    return bbox_data

# Function to predict and visualize results on video
def predict_video(video_path, model, metadata_file):
    model.predict_video(input_video_path=video_path, metadata_file=metadata_file, visualize=True, resize=True)

# Accept image and video file paths from the user
img_file = input("Enter the path to the image file: ")  # Example: 'test_img.jpg'
video_file = input("Enter the path to the video file: ")  # Example: 'test_video.mp4'
metadata_file = 'metadata.csv'  # Path to the metadata file associated with the video

# Predict on the image
predict_image(img_file, ssd)

# Predict on the video
predict_video(video_file, ssd, metadata_file)

# Publish results to GIS (for video detections)
df = pd.read_csv(metadata_file)

# Handle NAN and '\n' values
df.vmtilocaldataset = df.vmtilocaldataset.str.strip()
df.loc[df.vmtilocaldataset == '', 'vmtilocaldataset'] = ''
df['count'] = (df['vmtilocaldataset'].str.split(';').str.len().fillna(1) - 1)

# Grouping by frame and getting max detections per group
fps = 60
a = (pd.Series(df.index.values) / fps)
a = (a - .49).round().abs()
df['group'] = a

# Get index of row with max detections in each group
max_detection_idxes = df[['group', 'count']].groupby('group').idxmax()['count'].values

# Extract rows for the indexes
df_flt = df.iloc[max_detection_idxes]
df_flt.drop(df_flt.loc[df['count'] == 0].index, inplace=True)

# Create spatial data frame for GIS
sdf = GeoAccessor.from_xy(df_flt, 'Sensor Longitude', 'Sensor Latitude')

# Publish the result as a layer in GIS
cracks_lyr = gis.content.import_data(sdf, title='pavement_crack_points')

# Visualize the GIS map
m1 = gis.map('Haryana, India')  # Set the desired location
m1.basemap.basemap = "satellite"  # Set the basemap
m1.content.add(cracks_lyr)  # Add the layer with detected cracks

# Apply a renderer to visualize the results
rend_manager = m1.content.renderer(0)
smm = rend_manager.smart_mapping()
smm.class_breaks_renderer(break_type="size", field="count_")

# Display the map
m
