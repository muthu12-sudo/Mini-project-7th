import streamlit as st
import os
import zipfile
from pathlib import Path
from arcgis.gis import GIS
from arcgis.features import GeoAccessor
from fastai.vision.all import *
import cv2
import pandas as pd
import numpy as np

# Initialize GIS
api_key = 'YOUR_API_KEY'
gis = GIS(api_key=api_key)

# Load trained model
def load_model(model_path):
    learn = load_learner(model_path)
    return learn

# Predict on image
def predict_image(model, img_path):
    img = PILImage.create(img_path)
    return model.predict(img)

# Predict on video
def predict_video(model, video_path, metadata_path):
    cap = cv2.VideoCapture(video_path)
    fps = int(cap.get(cv2.CAP_PROP_FPS))
    frame_count = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
    
    metadata = []
    
    for i in range(frame_count):
        ret, frame = cap.read()
        if not ret:
            break
        
        # Convert frame to PILImage
        frame_img = PILImage.create(frame)
        
        # Predict
        pred_class, pred_idx, outputs = model.predict(frame_img)
        
        # Store predictions
        metadata.append({
            'frame': i,
            'prediction': pred_class,
            'confidence': outputs[pred_idx].item()
        })
        
    # Save metadata to CSV
    df = pd.DataFrame(metadata)
    df.to_csv(metadata_path, index=False)
    cap.release()
    return df

# Publish results to GIS
def publish_to_gis(metadata_file):
    df = pd.read_csv(metadata_file)
    
    # Handle missing or invalid metadata
    df['count'] = df['prediction'].apply(lambda x: 1 if x != 'None' else 0)
    
    # Filter non-detection frames
    df_flt = df[df['count'] > 0]
    
    # Create GeoDataFrame
    sdf = GeoAccessor.from_xy(df_flt, 'longitude', 'latitude')  # Adjust columns if needed
    
    # Create GIS Layer
    cracks_layer = gis.content.import_data(sdf, title='Pavement Cracks')
    
    # Return GIS layer object
    return cracks_layer

# Streamlit UI
st.title('Pavement Crack Detection')

# User inputs: Upload image and video files
img_file = st.file_uploader("Upload an Image", type=["jpg", "jpeg", "png"])
video_file = st.file_uploader("Upload a Video", type=["mp4", "avi"])

# Upload model .pth file
model_file = st.file_uploader("Upload the Model", type=["pth"])

# Process files if they are uploaded
if model_file and img_file and video_file:
    # Save uploaded model and load it
    model_path = Path("model.pth")
    with open(model_path, "wb") as f:
        f.write(model_file.read())
    
    model = load_model(model_path)
    
    # Save uploaded image and video
    img_path = Path("uploaded_img.jpg")
    with open(img_path, "wb") as f:
        f.write(img_file.read())
    
    video_path = Path("uploaded_video.mp4")
    with open(video_path, "wb") as f:
        f.write(video_file.read())
    
    # Predict on image
    img_pred_class, img_pred_idx, img_outputs = predict_image(model, img_path)
    
    # Display predicted image
    st.image(img_path, caption='Uploaded Image', use_column_width=True)
    st.write(f"Prediction: {img_pred_class}, Confidence: {img_outputs[img_pred_idx]:.4f}")
    
    # Predict on video
    metadata_path = Path("video_metadata.csv")
    video_df = predict_video(model, video_path, metadata_path)
    
    # Display results from video metadata
    st.write("Video Metadata:")
    st.dataframe(video_df)
    
    # Publish to GIS
    cracks_layer = publish_to_gis(metadata_path)
    
    # Display the GIS layer
    st.write("Results Published to GIS:")
    st.write(cracks_layer)

else:
    st.warning("Please upload the image, video, and model file to continue.")
