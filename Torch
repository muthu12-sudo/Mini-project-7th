import torch
import torchvision.models as models
import cv2
import streamlit as st
from pathlib import Path
from arcgis.gis import GIS
from arcgis.features import GeoAccessor
import pandas as pd
import tempfile

# Streamlit App
st.title("Pavement Crack Detection")
st.write("Upload images or videos, detect cracks, and save results to GIS.")

# Define Model Architecture (e.g., ResNet101 if used during training)
class CustomModel(torch.nn.Module):
    def __init__(self, num_classes):
        super(CustomModel, self).__init__()
        self.base_model = models.resnet101(pretrained=False)
        self.base_model.fc = torch.nn.Linear(2048, num_classes)  # Adjust output layer

    def forward(self, x):
        return self.base_model(x)

# Initialize model and load weights
num_classes = 2  # Adjust based on your dataset (e.g., 2 for binary classification)
model = CustomModel(num_classes=num_classes)
MODEL_PATH = "pavement-cracks-model-resnet101.pth"  # Path to your .pth file
model.load_state_dict(torch.load(MODEL_PATH, map_location=torch.device('cpu')))
model.eval()  # Set the model to evaluation mode

# Initialize GIS
api_key = "your-api-key"  # Replace with your API key
gis = GIS(api_key=api_key)

# Helper Function: Run Inference on Image
def predict_image(image_path, model):
    image = cv2.imread(image_path)
    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    transform = torch.nn.functional.interpolate  # Update with your actual preprocessing
    input_tensor = torch.tensor(image).permute(2, 0, 1).unsqueeze(0).float() / 255.0
    predictions = model(input_tensor)  # Run inference
    return predictions

# Image Upload and Prediction
uploaded_image = st.file_uploader("Upload an image (jpg/png)", type=["jpg", "png"])
if uploaded_image:
    with tempfile.NamedTemporaryFile(delete=False, suffix=".jpg") as tmp_file:
        tmp_file.write(uploaded_image.read())
        image_path = tmp_file.name

    st.image(image_path, caption="Uploaded Image", use_column_width=True)

    # Predict cracks
    st.write("Running inference...")
    predictions = predict_image(image_path, model)

    # Visualize results (you can replace this with your own bounding box visualization logic)
    st.write("Predictions:", predictions)

    # Save results to GIS
    st.write("Saving results to GIS...")
    detections = []  # Replace this with extracted bounding box coordinates from predictions
    for box in predictions:  # This loop should process your model's predictions
        detections.append({"X": box[0], "Y": box[1], "Class": "Crack"})

    sdf = GeoAccessor.from_xy(pd.DataFrame(detections), "X", "Y")
    cracks_layer = gis.content.import_data(sdf, title="Image Crack Detections")
    st.success("Results uploaded to GIS successfully!")
    st.write(cracks_layer)
