import torch
import torchvision.transforms as transforms
from PIL import Image
import cv2
import pandas as pd
import streamlit as st
from arcgis.gis import GIS
from arcgis.features import GeoAccessor
import tempfile
import os

# Streamlit App
st.title("Pavement Crack Detection")
st.write("Upload images or videos, detect cracks, and save results to GIS.")

# Define Model Architecture (Replace this with your architecture used during training)
class CustomModel(torch.nn.Module):
    def __init__(self, num_classes):
        super(CustomModel, self).__init__()
        self.base_model = torch.hub.load('pytorch/vision', 'resnet101', pretrained=False)
        self.base_model.fc = torch.nn.Linear(2048, num_classes)  # Adjust for your output classes

    def forward(self, x):
        return self.base_model(x)

# Load Model
num_classes = 2  # Adjust based on your dataset
model = CustomModel(num_classes=num_classes)

MODEL_PATH = "pavement-cracks-model-resnet101.pth"  # Path to your model file
model.load_state_dict(torch.load(MODEL_PATH, map_location=torch.device('cpu')))
model.eval()  # Set model to evaluation mode

# Initialize GIS
api_key = "your-api-key"  # Replace with your GIS API key
gis = GIS(api_key=api_key)

# Preprocessing Function (Modify based on your training pipeline)
def preprocess_image(image_path):
    image = Image.open(image_path).convert("RGB")
    transform = transforms.Compose([
        transforms.Resize((224, 224)),  # Adjust size if needed
        transforms.ToTensor(),
        transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
    ])
    return transform(image).unsqueeze(0)  # Add batch dimension

# Inference Function
def predict_image(image_path, model):
    input_tensor = preprocess_image(image_path)
    with torch.no_grad():
        predictions = model(input_tensor)
    return predictions

# Image Upload and Prediction
uploaded_image = st.file_uploader("Upload an image (jpg/png)", type=["jpg", "png"])
if uploaded_image:
    with tempfile.NamedTemporaryFile(delete=False, suffix=".jpg") as tmp_file:
        tmp_file.write(uploaded_image.read())
        image_path = tmp_file.name

    st.image(image_path, caption="Uploaded Image", use_column_width=True)

    # Predict cracks
    st.write("Running inference...")
    predictions = predict_image(image_path, model)

    # Process model output (update based on your model's output format)
    st.write("Predictions (raw):", predictions)

    # Save results to GIS
    st.write("Saving results to GIS...")
    detections = []  # Replace this with bounding box data if available
    detections.append({"X": 76.987, "Y": 28.704, "Class": "Crack"})  # Example

    sdf = GeoAccessor.from_xy(pd.DataFrame(detections), "X", "Y")
    cracks_layer = gis.content.import_data(sdf, title="Image Crack Detections")
    st.success("Results uploaded to GIS successfully!")
    st.write(cracks_layer)

# Video Upload and Prediction
uploaded_video = st.file_uploader("Upload a video (mp4/avi)", type=["mp4", "avi"])
if uploaded_video:
    with tempfile.NamedTemporaryFile(delete=False, suffix=".mp4") as tmp_file:
        tmp_file.write(uploaded_video.read())
        video_path = tmp_file.name

    st.video(video_path)

    # Process video frame by frame
    st.write("Processing video for crack detection...")
    cap = cv2.VideoCapture(video_path)
    frame_detections = []
    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break
        # Save frame as temporary image and predict
        temp_image_path = "temp_frame.jpg"
        cv2.imwrite(temp_image_path, frame)
        predictions = predict_image(temp_image_path, model)
        frame_detections.append(predictions)

    cap.release()

    # Save video detections to GIS
    st.write("Saving video results to GIS...")
    detections = []  # Update with bounding box data from video predictions
    detections.append({"X": 76.987, "Y": 28.704, "Class": "Crack"})  # Example

    sdf = GeoAccessor.from_xy(pd.DataFrame(detections), "X", "Y")
    video_layer = gis.content.import_data(sdf, title="Video Crack Detections")
    st.success("Video results uploaded to GIS successfully!")
    st.write(video_layer)
